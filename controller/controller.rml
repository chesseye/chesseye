open Types
open Util

let nb_repetition = 1
let validation_timeout = 0.5

(* let process is_stable_move pos mask_input = *)
(*   signal stop default false gather (or) in *)
(*   let m1 = mask_of_position pos in *)
(*   let cpt = ref 0 in *)
(*   do *)
(*     begin *)
(*       while (!cpt < nb_repetition) do *)
(*         await mask_input (Some m2) in *)
(*         if m1 = m2 then incr cpt; *)
(*       done; *)
(*       emit stop true *)
(*       || *)
(*       let start = Unix.gettimeofday () in *)
(*       loop *)
(*         for i = 1 to 10 do pause done; *)
(*         let now = Unix.gettimeofday () in *)
(*         if now -. start > 1.0 then emit stop false *)
(*       end *)
(*     end; *)
(*     assert false *)
(*   until stop(b) -> b done *)

let is_stable_move =
  let map = ref Dmov_map.empty in
  fun dmov ->
    try
      let history = Dmov_map.find dmov !map in
      let now = Unix.gettimeofday () in
      let stable =
        if List.length history >= 1 then
          true
        else
          List.exists (fun t -> now -. t > 1.) history
      in
      map := if stable then Dmov_map.empty else Dmov_map.add dmov now !map;
      stable
    with Not_found ->
      map := Dmov_map.add dmov (Unix.gettimeofday ()) !map;
      false

let process position_of_mask mask_input pos_output pos_init =
  let rec process position_of_mask pos m1 =
    await mask_input (Some m2) in
    let dmove = dmove_of_masks m1 m2 in
    let pos' = make_dmove pos dmove in
    if pos.number <> pos'.number then begin
      (* let stable_move = run is_stable_move pos' mask_input in *)
      let stable_move = is_stable_move dmove in
      if stable_move then begin
        emit pos_output pos';
        run position_of_mask pos' (mask_of_position pos')
      end else begin
      run position_of_mask pos m1
      end
    end else begin
      run position_of_mask pos m1
    end
  in
  run position_of_mask pos_init (mask_of_position pos_init)


let process print_position pos_input =
  loop
    await pos_input(Some pos) in
    Ochess.print_full_suggestion pos;
    Ochess.print_position pos
  end

let keep_last x y =
  begin match y with
  | None -> Some x
  | Some _ ->
      warning "Drop event";
      Some x
  end

let process advice_engine pos_input advice_output =
  loop
    await pos_input (Some pos) in
    let smove = run Rml_async.proc_of_fun Ochess.suggest_move pos in
    (* let smove = Ochess.suggest_move pos in *)
    begin match last ?pos_input with
    | Some p ->
        if p.number = pos.number then
          emit advice_output (pos, smove)
    | None -> ()
    end
  end


let process check_init pos_input mask_input r =
  let init_mask = mask_of_position Ochess.init_position in
  loop
    await mask_input(Some m) in
    begin match last ?pos_input with
    | Some p ->
        if p.number <> Ochess.init_position.number && m = init_mask then
          (print_endline "REST";
           emit r)
    | None -> ()
    end
  end

let process output_messages position reset advice =
  loop
    await position (Some pos) in
    print_endline "MOVD"
  end
  ||
  loop
    await reset ( () ) in
    print_endline "REST"
  end
  ||
  loop
    await advice (Some (pos, smove)) in
    let msg = Ochess.string_of_move pos smove in
    print_endline ("KIBB "^msg)
  end

let process main =
  print_endline "The ChessEye controller is running";
  signal reset default () gather (fun () () -> ()) in
  signal mask default None gather keep_last in
  signal position default None gather keep_last in
  signal advice default None gather keep_last in
  begin
    run Rml_async.proc_of_fun Bridge.bridge mask;
    exit 0
    ||
    loop
      do
        run position_of_mask mask position Ochess.init_position
      until reset done
    end
    ||
    run print_position position
    ||
    run output_messages position reset advice
    ||
    run advice_engine position advice
    ||
    run check_init position mask reset
    (* || *)
    (* loop *)
    (*   for i = 1 to 100_000 do pause done; *)
    (*   print_endline "tick"; *)
    (*   pause *)
    (* end *)
    ||
    loop
      flush stderr;
      flush stdout;
      pause
    end
  end
let () = run main
